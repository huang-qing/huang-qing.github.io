---
layout: post
title: NPM CLI
subtitle: v7
date: 2021-08-28
author: huangqing
header-img: img/post-bg-npm.jpg
catalog: true
categories: [Web]
tags:
  - npm
---

![npm cli mindmap](/images/npm/npm-v7-cli-mindmap.png)

![npm mindmap](/images/npm/npm-mind-map.jpg)

`npm CLI`，CLI 就是 Command Line Interface，也就是我们说的命令行接口，具体可以参考[npm CLI commands](<(https://docs.npmjs.com/cli/v7/commands)>)。

## npm CLI 常见命令

### npm help

npm help 是个好命令。就像我用`git --help`一样，对于有些比较模糊的命令，用 help 来查一下。

### npm init

`npm init` 命令用来初始化一个简单的 `package.json` 文件，执行该命令后终端会依次询问 `name`, `version`, `description` 等字段。

```shell
npm init
# 直接生成默认配置的package.json
npm init --yes
```

npm 提供了名称空间策略 `scope`,`scope` 包包名格式：`@scope-name/pkg-name`

```shell
npm init --scope org
```

```json
{
  "name": "@org/name"
}
```

为 scope 绑定一个仓储

```shell
npm login --registry=http://reg.example.com --scope=@org
npm config set @org:registry http://reg.example.com
```

这样凡是碰到 `scope` 为 `@org` 的包，`npm` 将自动切换作业仓储到 `scope` 绑定的仓储，这提供了一种**多仓储策略**。

```shell
npm publish @org:registry http://reg.example.com
```

### npm init xxx

比如`npm init @vitejs/app`，是用来创建应用的，其背后是调用了`npx @vitejs/create-app`，其实就是在执行一个`create-app`脚本。

这也就是说，如果你想让别人通过`npm init xxx`命令调用你的包，就必须提供一个`create-xxx`脚本。

### npx

npx 用来运行本地或远程 npm 包的一个命令。比如前面提到的`npx @vitejs/create-app`。

如果 npx 请求的包（比如`@vitejs/create-app`）没有出现在本地项目的依赖中，npm 就会把`@vitejs/create-app`安装到全局的 `npm cache` 目录下。

接着会执行`create-app`脚本，而这个脚本需要定义在`package.json`的`bin`配置项下。

> `npm init xxx`和`npx create-xxx`也是一般 CLI 工具的常用套路。

### npm config

`npm config`是用来管理配置文件的，我们平时用的最多的是设置 npm 的源。

```shell
# 默认源为 https://registry.npmjs.org/
npm config set registry https://registry.npm.taobao.org
```

查看 npm 的所有配置，包括默认配置:

```shell
 npm config ls -l
```

### .npmrc 文件

除了使用 CLI 的 `npm config` 命令显示更改 npm 配置，还可以通过 `npmrc` 文件直接修改配置。

这样的 npmrc 文件优先级由高到低包括：

- 工程内配置文件: `/path/to/my/project/.npmrc`
- 用户级配置文件: `~/.npmrc`
- 全局配置文件: `$PREFIX/etc/npmrc` (即 `npm config get globalconfig` 输出的路径)
- npm 内置配置文件:`/path/to/npm/npmrc`

### npm install/uninstall

npm install 不指定包时，会将 package.json 列出的依赖安装到 node_modules 中，如果指定包名，则安装指定的包。主要注意：

- `-g`是全局安装；

- 如果指定了 `--production` ，或者 NODE_ENV 是 production，就不会安装 devDependencies 中的依赖。

- `--save` 等价于 `-S`，安装的依赖包信息保存到 package.json 中的 dependencies，这些依赖（比如 vue, react）如果有进入 bundler （比如 webpack ）的 Dependency Graph（依赖关系图），会被打包到项目的构建结果中；`npm install vue`会默认执行-S 的行为，但是建议显示给出`-S`，给人的感觉会比较清晰。

- `--save-dev` 等价于`-D`，安装的依赖包信息保存到 devDependencies 中，这些依赖一般是开发环境的工具，比如 eslint, webpack, babel 之类的，这些依赖一般不会被打包工具处理到构建结果中。

但是，如果你使用`npm install -D vue`安装了 vue，并且在项目中引用了 vue 依赖，那么 webpack 的 Dependency Graph 中也会有 vue，最终 vue 也会体现到构建结果中；webpack 不关心一个依赖是`dependencies`还是`devDependencies`，只要进入 webpack 的 Dependency Graph，就会打包到结果中。

实质上，我们在开发一个 Vue 组件时，仅仅需要把 vue 作为 devDependencies 即可。

### npm start

`npm start`是一个语义化的命令。通常我们会在 `scripts` 中自定义 `start` 脚本，比如：

```shell
"start": "npm run dev"
```

如果没有指定自定义的 start 脚本，`npm start`默认会执行：

```
node server.js
```

### npm run

`npm run`用来运行我们定义的`scripts`，命令后直接跟脚本名称就行。在`npm run`时，我们可以调用一些特殊路径下的可执行文件或脚本，这些路径包括环境变量`PATH`定义的路径，也包括当前项目`node_modules`中的`./bin`

### npm version

从语义上看，`npm version`会修改`package.json`中的`version`字段，用来管理包的版本号。

```shell
# 升级补丁版本号
npm version patch
# 升级小版本号
npm version minor
# 升级大版本号
npm version major
# 升级版本并添加备注
npm version major -m "reason for upgrade"
```

*major/minor/patch*三选一，分别代表主版本/次版本/补丁版本。当然也可以传其他的版本参数，具体参考[npm-version](https://docs.npmjs.com/cli/v7/commands/npm-version)。

通常，我们还会定义一个自定义的 `version` 脚本，配合`conventional-changelog`用来自动生成`CHANGELOG.md`。

```json
{
  "scripts": {
    "version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md"
  }
}
```

### npm login/ npm adduser

发布一个 npm 包的流程并不复杂。首先你必须通过命令行登录 npm，这用到了`npm adduser`，别名是`npm login`。

确保你的代理正确:有时候，考虑到国内环境，我们安装依赖时，会设置 npm 的源为淘宝镜像。但是在发布 npm 包之前，必须把源切回到 npm。

```
npm config set registry http://registry.npmjs.org/
```

### npm publish

发布一个 npm 包，发布的界限是以 version 判断的，不能发布相同的 version。即便你只是改了一个 README，也必须修改 version 才能重新 `npm publish`。

一个 node.js 模块是基于 CommonJS 模块化规范实现的，严格按照 CommonJS 规范，模块目录下除了必须包含包描述文件 package.json 以外，还需要包含以下目录：

- bin：存放可执行二进制文件的目录
- lib：存放 js 代码的目录
- doc：存放文档的目录
- test：存放单元测试用例代码的目录

### npm unpublish

与发包对应的就是移除已发布的包。你可以选择移除整个已发布的包，也可以针对性地下架某个版本。

### npm pack

将 package 打包成 tgz 格式

### npm link

`npm link`用于创建一个符号链接，类似于 Linux 软链接（`ln -s`）的效果。

首先需要在待创建 link 的包目录(比如 vue-x)下运行 `npm link`，这会在 npm 全局文件夹下创建一个 `symlink`。

`npm prefix -g`指向 npm 全局文件夹

`npm link`后，C:\Users\Tusi\AppData\Roaming\npm\node_modules\中就有一个 link 的目录了，其实是一个快捷方式。

同时，如果 vue-x 中有配置 bin 文件，也会被 link 到全局。

要用到 vue-x 的地方可以通过 npm link vue-x 安装它，也会安装到 node_modules 下，不过是一个全量的 vue-x，而非 npm publish 后的 vue-x。

**npm link 适合在本地对两个及以上的包做调试用，这样就不用每次调试问题时，还要重新 npm run build, npm publish，省去了很多事。**

## 脚本传入参数

```js
#!/usr/bin/env node
"use strict";
var pkg = require("./package.json");
var osName = require("./");
// 获取脚本传入参数
var argv = process.argv.slice(2);
```

> `process.argv` 属性返回一个数组，数组包含了启动 `node` 进程时的命令行参数。第一个元素为启动 `node` 进程的可执行文件的绝对路径名 `process.execPath`,第二个元素为当前执行的 `javascript` 文件路径。**剩余的元素为其他命令行参数**。

如下 `script` 例子:

```shell
"scripts":{
  "serve": "vue-cli-service serve --mode=dev --mobile -config build/example.js"
}
```

当我们执行 `npm run server` 命令的时候，`process.argv` 的具体内容为：

```js
[
  "/usr/local/Cellar/node/12.14.1/bin/node",
  "/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service",
  "serve",
  "--mode=dev",
  "--mobile",
  "-config",
  "build/example.js",
];
```

## 执行顺序

npm 脚本执行多任务分为两种情况

并行任务(同时的平行执行)，使用`&`符号

```shell
npm run script1.js & npm run script2.js
```

串行任务(前一个任务成功，才执行下一个任务)，使用 `&&` 符号

```shell
npm run script1.js && npm run script2.js
```

## 参考

- [npm init @vitejs/app 的背后，仅是 npm CLI 的冰山一角](https://juejin.cn/post/6950817077670182943)
- [你应该知道的 NPM 知识都在这！](https://mp.weixin.qq.com/s/sRhuMQ3f6vjUkabUy_dEYQ)
